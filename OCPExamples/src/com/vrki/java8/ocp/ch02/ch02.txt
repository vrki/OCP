Construct interfaces that have neither methods nor class members, traditionally referred to as marker interfaces.

There are additional rules for default methods, such as Java failing to compile if a class or interface inherits two default
methods with the same signature and doesn’t provide its own implementation.


Purpose of the interface:
An interface provides a way for one individual to develop code that uses another individual’s code, without having access to 
the other individual’s underlying implementation. Interfaces can facilitate rapid application development by enabling development
teams to create applications in parallel, rather than being directly dependent on each other.

For example, two teams can work together to develop a one-page standard interface at the start of a project. One team then 
develops code that uses the interfaces while the other team develops code that implements the interface. The development teams
can then combine their implementations toward the end of the project, and as long as both teams developed with the same 
interface, they will be compatible. Of course, testing will still be required to make sure that the class implementing the 
interface behaves as expected.

---------------------------------------------------------------------------------------------------------------------------------
Real World Scenario:

Mock Objects:

You might wonder how a developer using the interface can build their code without access to a class that implements the 
interface. The developer using the interface can create a temporary mock object, sometimes referred to as dummy code, which
simulates the real object that implements the interface with a simple implementation. The mock object does not need to be 
very complex, with one line per abstract method, for example, as it only serves as a placeholder for the real implementation.
This allows the developer using the interface to compile, run, and test their code. 

For example, imagine that you were working on a racing application with the code that calculates the winners handled by a 
different team. Both your team and the other team agreed on a RaceManager interface, as shown in the following code, with your
team using the interface and the other team implementing it:

public class Animal {}
public class Tortoise extends Animal {}
public class Hare extends Animal {}
public interface RaceManager {
	public Animal getWinner(List<Animal> animals);
}

The good news is that your team has finished its part of the project first. The bad news is that the other team has nothing for
you to test with. While waiting for the other team to finish, you can create a mock version of the RaceManager class, as shown 
in the following sample code:

public class DummyRaceManager implements RaceManager {
	public Animal getWinner(List<Animal> animals) {
		return animals==null || animals.size()==0 ? null: animals.get(0);
	}
}

The code isn’t particularly intelligent; after all it just returns the first item in the list, but it is useful for testing 
purposes because it allows your team to execute your code while the other team finishes their implementation. You could also
write a version that always returns Tortoise or Hare. The goal is just to give you something temporary that you can work with
and that allows your code to compile, regardless of whether it works exactly as expected. After all, the full implementation of
getWinner() could be hundreds of lines long and based on very complex business rules.

---------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
** Introducing Functional Programming
---------------------------------------------------------------------------------------------------------------------------------

Java defines a functional interface as an interface that contains a single abstract method. Functional interfaces are used as the
basis for lambda expressions in functional programming. A lambda expression is a block of code that gets passed around, like an 
anonymous method.

---------------------------------------------------------------------------------------------------------------------------------
** Defining a Functional Interface
---------------------------------------------------------------------------------------------------------------------------------

@FunctionalInterface
public interface Sprint {
	public void sprint(Animal animal);
}

public class Tiger implements Sprint {
	public void sprint(Animal animal) {
		System.out.println("Animal is sprinting fast! "+animal.toString());
	}
}

In this example, the Sprint class is a functional interface, because it contains exactly one abstract method, and the Tiger class
is a valid class that implements the interface.

Lambda expressions rely on the notion of deferred execution. Deferred execution means that code is specified now but runs later.
Even though the execution is deferred, the compiler will still validate that the code syntax is properly formed.

---------------------------------------------------------------------------------------------------------------------------------
** Understanding Lambda Syntax
---------------------------------------------------------------------------------------------------------------------------------

The left side of the arrow operator -> indicates the input parameters for the lambda expression.
The right side is referred to as the body of the lambda expression.

As mentioned, the data types for the input parameters of a lambda expression are optional. When one parameter has a data type 
listed, though, all parameters must provide a data type.

There is one more issue you might see with lambdas. We’ve been defining an argument list in our lambda expressions. Since Java
doesn’t allow us to re-declare a local variable, the following is an issue:

(a, b) -> { int a = 0; return 5;} // DOES NOT COMPILE

We tried to re-declare a, which is not allowed. By contrast, the following line is permitted because it uses a different variable
name:

(a, b) -> { int c = 0; return 5;}

---------------------------------------------------------------------------------------------------------------------------------
** Applying the Predicate Interface
---------------------------------------------------------------------------------------------------------------------------------
It’s in the package java.util.function:

public interface Predicate<T> {
	public boolean test(T t);
}


The result of using Predicate is that we no longer need our own functional interface. The following is a rewrite of our program
to use the Predicate class:

import java.util.function.Predicate;

public class FindMatchingAnimals {
	private static void print(Animal animal, Predicate<Animal> trait) {
	if(trait.test(animal))
		System.out.println(animal);
	}

	public static void main(String[] args) {
		print(new Animal("fish", false, true), a -> a.canHop());
		print(new Animal("kangaroo", true, false), a -> a.canHop());
	}
}

---------------------------------------------------------------------------------------------------------------------------------
** Implementing Polymorphism
---------------------------------------------------------------------------------------------------------------------------------

Polymorphism is the ability of a single interface to support multiple underlying forms. In Java, this allows multiple types of 
objects to be passed to a single method or class.


